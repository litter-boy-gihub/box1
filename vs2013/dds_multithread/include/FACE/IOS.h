// DISTRIBUTION STATEMENT A. Approved for public release; distribution is unlimited. 
// 
// Product produced under DoD SENSIAC contract HC104705D4000 under
// the sponsorship of the Defense Technical Information Center,
// ATTN: DTIC-AI, 8723 John J. Kingman Rd., Ste 0944, Fort Belvoir, VA
// 22060-6218.  SENSIAC is a DoD Information Analysis Center Sponsored
// by the Defense Technical Information Center.
// 
// HANDLING AND DESTRUCTION NOTICE - Comply with distribution statement
// and destroy by any method that will prevent disclosure of
// contents or reconstruction of the document.

#ifndef _FACE_IOS_H_
#define _FACE_IOS_H_

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

typedef FACE_char FACE_INTERFACE_NAME_TYPE[30];

typedef FACE_unsigned_long FACE_MESSAGE_LENGTH_TYPE;

typedef enum
{
  FACE_MIL_STD_1553,
  FACE_ARINC_429,
  FACE_SERIAL,
  FACE_DISCRETE,
  FACE_ANALOG,
  FACE_SYNCHRO,
  FACE_HIGH_PRECISION_SYNCHRO,
  FACE_VME,
  FACE_GENERIC_BUS,
  FACE_USER_DEFINED_BUS_1,
  FACE_USER_DEFINED_BUS_2,
  FACE_USER_DEFINED_BUS_3,
  FACE_USER_DEFINED_BUS_n
}   FACE_BUS_TYPE;

typedef enum
{
  FACE_GO,
  FACE_NOGO,
  FACE_IDLE,
  FACE_DEGRADED
}   FACE_IO_CONNECTION_STATUS_TYPE;

typedef struct {
  FACE_SYSTEM_TIME_TYPE last_message_time;
  FACE_boolean message_available;
  FACE_IO_CONNECTION_STATUS_TYPE connection_status;
}   FACE_STATUS_TYPE;

typedef enum
{
  FACE_COMMAND,
  FACE_STATUS,
  FACE_DATA,
  FACE_USER_DEFINED
}   FACE_MESSAGE_TYPE;

typedef enum
{
  FACE_OPEN,
  FACE_REGISTER,
  FACE_READ,
  FACE_WRITE,
  FACE_CLOSE,
  FACE_GET_STATUS,
  FACE_UNREGISTER
}   FACE_COMMAND_TYPE;

typedef enum
{
  FACE_A429_IO_HW_OPERATIONAL,
  FACE_A429_IO_HW_FIFO_OVERFLOW,
  FACE_A429_IO_SW_CIRCULAR_BUFF_OVERFLOW,
  FACE_A429_IO_HW_ADDRESS_ERROR,
  FACE_A429_IO_HW_SEQUENCE_ERROR,
  FACE_A429_IO_HW_PARITY_ERROR,
  FACE_A429_IO_CLOCK_LOSS,
  FACE_A429_IO_UNKNOWN_ERROR
}   FACE_A429_STATUS_TYPE;

typedef enum
{
  FACE_M1553_BC_IO_NO_RESPONSE,
  FACE_M1553_BC_IO_LOOP_TEST_FAIL,
  FACE_M1553_BC_IO_MSG_RETRIED,
  FACE_M1553_BC_IO_BAD_DATA_BLOCK,
  FACE_M1553_BC_IO_ADDRESS_ERROR,
  FACE_M1553_BC_IO_WORD_COUNT_ERROR,
  FACE_M1553_BC_IO_SYNC_ERROR,
  FACE_M1553_BC_IO_INVALID_WORD,
  FACE_M1553_RT_IO_TERMINAL_FLAG,
  FACE_M1553_RT_IO_SUBSYSTEM_FLAG,
  FACE_M1553_RT_IO_SERVICE_REQUEST,
  FACE_M1553_RT_IO_BUSY,
  FACE_M1553_RT_IO_DYNAMIC_BC,
  FACE_M1553_RT_IO_NO_RESPONSE,
  FACE_M1553_RT_IO_LOOP_TEST_FAIL,
  FACE_M1553_RT_IO_ILLEGAL_COMMAND_WORD,
  FACE_M1553_RT_IO_WORD_COUNT_ERROR,
  FACE_M1553_RT_IO_SYNC_ERROR,
  FACE_M1553_RT_IO_INVALID_WORD,
  FACE_M1553_RT_IO_RT_RT_GAP_SYNC_ADDR_ERROR,
  FACE_M1553_RT_IO_RT_RT_2ND_CMD_ERROR,
  FACE_M1553_RT_IO_COMMAND_WORD_ERROR,
  FACE_M1553_BM_IO_NO_RESPONSE,
  FACE_M1553_BM_IO_WORD_COUNT_ERROR,
  FACE_M1553_BM_IO_SYNC_ERROR,
  FACE_M1553_BM_IO_INVALID_WORD,
  FACE_M1553_BM_IO_RT_RT_GAP_SYNC_ADDR_ERROR,
  FACE_M1553_BM_IO_RT_RT_2ND_CMD_ERROR,
  FACE_M1553_BM_IO_COMMAND_WORD_ERROR,
  FACE_M1553_BM_IO_BAD_DATA_BLOCK,
  FACE_M1553_BM_IO_MESSAGE_ERROR,
  FACE_M1553_BM_IO_INSTRUMENTATION,
  FACE_M1553_BM_IO_SERVICE_REQUEST,
  FACE_M1553_BM_IO_RESERVED_BITS,
  FACE_M1553_BM_IO_BROADCAST_RCVD,
  FACE_M1553_BM_IO_BUSY,
  FACE_M1553_BM_IO_SF,
  FACE_M1553_BM_IO_DYNAMIC_BC,
  FACE_M1553_BM_IO_TF,
  FACE_M1553_DRIVER_READY,
  FACE_M1553_DRIVER_ERROR,
  FACE_M1553_UNKNOWN_ERROR,
  FACE_M1553_RX_SUCCESS,
  FACE_M1553_TX_SUCCESS,
  FACE_M1553_RXMODE_SUCCESS,
  FACE_M1553_TXMODE_SUCCESS,
  FACE_M1553_RT_TO_RT_SUCCESS,
  FACE_M1553_BC_IO_GO,
  FACE_M1553_BC_IO_NOGO_A,
  FACE_M1553_BC_IO_NOGO_B,
  FACE_M1553_BC_IO_NOGO_T
}   FACE_M1553_STATUS_TYPE;

typedef enum
{
  FACE_M1553_CMD,
  FACE_M1553_STATUS,
  FACE_M1553_DATA
}   FACE_M1553_WORD_TYPE;

typedef enum
{
  FACE_SERIAL_DEVICE_OPERATIONAL,
  FACE_SERIAL_OVERRUN_ERROR,
  FACE_SERIAL_PARITY_ERROR,
  FACE_SERIAL_FRAMING_ERROR,
  FACE_SERIAL_BREAK_ERROR
}   FACE_SERIAL_STATUS_TYPE;

#define FACE_DISCRETE_ERROR ((FACE_short) 1)

#define FACE_ANALOG_ERROR ((FACE_short) 1)

typedef FACE_SYSTEM_ADDRESS_TYPE FACE_MESSAGE_ADDR_TYPE;

typedef FACE_SYSTEM_ADDRESS_TYPE FACE_INTERFACE_HANDLE_TYPE;

typedef void (*FACE_CALLBACK_ADDRESS_TYPE)
  ( /* in */ FACE_MESSAGE_LENGTH_TYPE message_length,
    /* in */ FACE_MESSAGE_ADDR_TYPE data_buffer_address,
    /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Initialize (
  /* in */ FACE_CONFIGURATION_RESOURCE configuration,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Open (
  /* in */ FACE_INTERFACE_NAME_TYPE name,
  /* in */ FACE_TIMEOUT_TYPE timeout,
  /* out */ FACE_INTERFACE_HANDLE_TYPE * handle,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Register (
  /* in */ FACE_INTERFACE_HANDLE_TYPE handle,
  /* in */ FACE_CALLBACK_ADDRESS_TYPE callback_address,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Unregister (
  /* in */ FACE_INTERFACE_HANDLE_TYPE handle,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Read (
  /* in */ FACE_INTERFACE_HANDLE_TYPE handle,
  /* in */ FACE_TIMEOUT_TYPE timeout,
  /* inout */ FACE_MESSAGE_LENGTH_TYPE * message_length,
  /* in */ FACE_MESSAGE_ADDR_TYPE data_buffer_address,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Write (
  /* in */ FACE_INTERFACE_HANDLE_TYPE handle,
  /* in */ FACE_TIMEOUT_TYPE timeout,
  /* in */ FACE_MESSAGE_LENGTH_TYPE message_length,
  /* in */ FACE_MESSAGE_ADDR_TYPE data_buffer_address,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Get_Status (
  /* in */ FACE_INTERFACE_HANDLE_TYPE handle,
  /* out */ FACE_STATUS_TYPE * status,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

void
FACE_IO_Close (
  /* in */ FACE_INTERFACE_HANDLE_TYPE handle,
  /* out */ FACE_RETURN_CODE_TYPE * return_code);

#ifdef __cplusplus
}
#endif /* __cplusplus */


#endif /* #ifndef */